<html><head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>fmincon</title>
    <style type="text/css" media="all">
      @import url("scilab_code.css");
      @import url("xml_code.css");
      @import url("c_code.css");
      @import url("style.css");
    </style>
  </head>
  <body>
    <div class="manualnavbar">
    <table width="100%"><tr>
      <td width="30%">
    	<span class="previous"><a href="section_ed3c614d9a2555a6802170ca29940f55.html">&lt;&lt; Fmincon Toolbox</a></span>

      </td>
      <td width="40%" class="center">
      	<span class="top"><a href="section_ed3c614d9a2555a6802170ca29940f55.html">Fmincon Toolbox</a></span>

      </td>
      <td width="30%" class="next">
      	<span class="next"><a href="optimget.html">optimget &gt;&gt;</a></span>

      </td>
    </tr></table>
      <hr />
    </div>



    <span class="path"><a href="index.html">Fmincon Toolbox</a> &gt;&gt; <a href="section_ed3c614d9a2555a6802170ca29940f55.html">Fmincon Toolbox</a> &gt; fmincon</span>

    <br /><br />
    <div class="info"></div>

  <div class="refnamediv"><h1 class="refname">fmincon</h1><p class="refpurpose">Solves a nonlinearily constrained optimization problem.</p></div>



<div class="refsynopsisdiv"><h3 class="title">Calling Sequence</h3>
   <div class="synopsis"><pre><span class="default">x</span><span class="default"> = </span><span class="functionid">fmincon</span><span class="default">(</span><span class="default">fun</span><span class="default">,</span><span class="default">x0</span><span class="default">)</span>
<span class="default">x</span><span class="default"> = </span><span class="functionid">fmincon</span><span class="default">(</span><span class="default">fun</span><span class="default">,</span><span class="default">x0</span><span class="default">,</span><span class="default">A</span><span class="default">,</span><span class="default">b</span><span class="default">)</span>
<span class="default">x</span><span class="default"> = </span><span class="functionid">fmincon</span><span class="default">(</span><span class="default">fun</span><span class="default">,</span><span class="default">x0</span><span class="default">,</span><span class="default">A</span><span class="default">,</span><span class="default">b</span><span class="default">,</span><span class="default">Aeq</span><span class="default">,</span><span class="default">beq</span><span class="default">)</span>
<span class="default">x</span><span class="default"> = </span><span class="functionid">fmincon</span><span class="default">(</span><span class="default">fun</span><span class="default">,</span><span class="default">x0</span><span class="default">,</span><span class="default">A</span><span class="default">,</span><span class="default">b</span><span class="default">,</span><span class="default">Aeq</span><span class="default">,</span><span class="default">beq</span><span class="default">,</span><span class="default">lb</span><span class="default">,</span><span class="default">ub</span><span class="default">)</span>
<span class="default">x</span><span class="default"> = </span><span class="functionid">fmincon</span><span class="default">(</span><span class="default">fun</span><span class="default">,</span><span class="default">x0</span><span class="default">,</span><span class="default">A</span><span class="default">,</span><span class="default">b</span><span class="default">,</span><span class="default">Aeq</span><span class="default">,</span><span class="default">beq</span><span class="default">,</span><span class="default">lb</span><span class="default">,</span><span class="default">ub</span><span class="default">,</span><span class="default">nonlcon</span><span class="default">)</span>
<span class="default">x</span><span class="default"> = </span><span class="functionid">fmincon</span><span class="default">(</span><span class="default">fun</span><span class="default">,</span><span class="default">x0</span><span class="default">,</span><span class="default">A</span><span class="default">,</span><span class="default">b</span><span class="default">,</span><span class="default">Aeq</span><span class="default">,</span><span class="default">beq</span><span class="default">,</span><span class="default">lb</span><span class="default">,</span><span class="default">ub</span><span class="default">,</span><span class="default">nonlcon</span><span class="default">,</span><span class="default">options</span><span class="default">)</span>
<span class="default">[</span><span class="default">x</span><span class="default">,</span><span class="default">fval</span><span class="default">,</span><span class="default">exitflag</span><span class="default">,</span><span class="default">output</span><span class="default">,</span><span class="default">lambda</span><span class="default">,</span><span class="default">grad</span><span class="default">,</span><span class="default">hessian</span><span class="default">] = </span><span class="functionid">fmincon</span><span class="default"> ( ... )</span></pre></div></div>

<div class="refsection"><h3 class="title">Parameters</h3>
   <dl><dt><span class="term">fun:</span>
      <dd><p class="para">a function, the function to minimize. See below for the complete specifications.</p></dd></dt>
   <dt><span class="term">x0:</span>
      <dd><p class="para">a nx1 or 1xn matrix of doubles, where n is the number of variables. The initial guess for the optimization algorithm.</p></dd></dt>
   <dt><span class="term">A:</span>
      <dd><p class="para">a nil x n matrix of doubles, where n is the number of variables and nil is the number of linear inequalities. If A==[] and b==[], it is assumed that there is no linear inequality constraints. If (A==[] &amp; b&lt;&gt;[]), fmincon generates an error (the same happens if (A&lt;&gt;[] &amp; b==[])).</p></dd></dt>
   <dt><span class="term">b:</span>
      <dd><p class="para">a nil x 1 matrix of doubles, where nil is the number of linear inequalities.</p></dd></dt>
   <dt><span class="term">Aeq:</span>
      <dd><p class="para">a nel x n matrix of doubles, where n is the number of variables and nel is the number of linear equalities.  If A==[] and b==[], it is assumed that there is no linear equality constraints. If (Aeq==[] &amp; beq&lt;&gt;[]), fmincon generates an error (the same happens if (Aeq&lt;&gt;[] &amp; beq==[])).</p></dd></dt>
   <dt><span class="term">beq:</span>
      <dd><p class="para">a nel x 1 matrix of doubles, where nel is the number of linear inequalities.</p></dd></dt>
   <dt><span class="term">lb:</span>
      <dd><p class="para">a nx1 or 1xn matrix of doubles, where n is the number of variables. The lower bound for x. If lb==[], then the lower bound is automatically set to -inf.</p></dd></dt>
   <dt><span class="term">ub:</span>
      <dd><p class="para">a nx1 or 1xn matrix of doubles, where n is the number of variables. The upper bound for x. If lb==[], then the upper bound is automatically set to +inf.</p></dd></dt>
   <dt><span class="term">nonlcon:</span>
      <dd><p class="para">a function, the nonlinear constraints. See below for the complete specifications.</p></dd></dt>
   <dt><span class="term">x:</span>
      <dd><p class="para">a nx1 matrix of doubles, the computed solution of the optimization problem</p></dd></dt>
   <dt><span class="term">fval:</span>
      <dd><p class="para">a 1x1 matrix of doubles, the function value at x</p></dd></dt>
   <dt><span class="term">exitflag:</span>
      <dd><p class="para">a 1x1 matrix of floating point integers, the exit status. See below for details.</p></dd></dt>
   <dt><span class="term">output:</span>
      <dd><p class="para">a struct, the details of the optimization process.  See below for details.</p></dd></dt>
   <dt><span class="term">lambda:</span>
      <dd><p class="para">a struct, the Lagrange multipliers at optimum.  See below for details.</p></dd></dt>
   <dt><span class="term">grad:</span>
      <dd><p class="para">a nx1 matrix of doubles, the gradient of the objective function at optimum</p></dd></dt>
   <dt><span class="term">hessian:</span>
      <dd><p class="para">a nxn matrix of doubles, the Hessian of the objective function at optimum</p></dd></dt>
   <dt><span class="term">options:</span>
      <dd><p class="para">an optional struct, as provided by optimset</p></dd></dt></dl></div>

<div class="refsection"><h3 class="title">Description</h3>
   <p class="para">Search the minimum of a constrained optimization problem specified by :
find the minimum of f(x) such that</p>
   <p class="para">c(x)&lt;=0, ceq(x)&lt;=0, A*x&lt;=b, Aeq*x=beq and lb&lt;=x&lt;=ub.</p>
   <p class="para"><span><img src='./_LaTeX_fmincon.xml_1.png' style='position:relative;top:64px;width:186px;height:136px'/></span></p>
   <p class="para">Currently, we use ipopt for the actual solver of fmincon.</p>
   <p class="para">See the demonstrations for additionnal examples.</p>
   <p class="para">The objective function must have header :
<div class="programlisting"><table border="0" width="100%"><tr><td width="98%"><pre class="scilabcode"><span class="scilabid">f</span> <span class="scilaboperator">=</span> <span class="scilabid">objfun</span> <span class="scilabopenclose">(</span> <span class="scilabid">x</span> <span class="scilabopenclose">)</span></pre></td><td valign="top"><a href="scilab://scilab.execexample/"><img src="ScilabExecute.png" border="0"/></a></td><td valign="top"><a href="scilab://scilab.editexample/"><img src="ScilabEdit.png" border="0"/></a></td><td></td></tr></table></div>
where x is a n x 1 matrix of doubles and f is a 1 x 1 matrix of doubles.
On input, the variable x contains the current point and, on output,
the variable f must contain the objective function value.</p>
   <p class="para">By default, fmincon uses finite differences with order 2 formulas and
optimum step size in order to compute a numerical gradient of the
objective function.
If we can provide exact gradients, we should do so since it improves
the convergence speed of the optimization algorithm.
In order to use exact gradients, we must update the header of the
objective function to :
<div class="programlisting"><table border="0" width="100%"><tr><td width="98%"><pre class="scilabcode"><span class="scilabopenclose">[</span><span class="scilabid">f</span><span class="scilabdefault">,</span><span class="scilabid">G</span><span class="scilabopenclose">]</span> <span class="scilaboperator">=</span> <span class="scilabid">objfungrad</span> <span class="scilabopenclose">(</span> <span class="scilabid">x</span> <span class="scilabopenclose">)</span></pre></td><td valign="top"><a href="scilab://scilab.execexample/"><img src="ScilabExecute.png" border="0"/></a></td><td valign="top"><a href="scilab://scilab.editexample/"><img src="ScilabEdit.png" border="0"/></a></td><td></td></tr></table></div>
where x is a n x 1 matrix of doubles, f is a 1 x 1 matrix of doubles
and G is a n x 1 matrix of doubles.
On input, the variable x contains the current point and, on output,
the variable f must contain the objective function value and the variable
G must contain the gradient of the objective function.
Furthermore, we must enable the &#0034;GradObj&#0034; option with the statement :
<div class="programlisting"><table border="0" width="100%"><tr><td width="98%"><pre class="scilabcode"><span class="scilabid">options</span> <span class="scilaboperator">=</span> <a class="scilabmacro" href="optimset.html">optimset</a><span class="scilabopenclose">(</span><span class="scilabstring">&#0034;</span><span class="scilabstring">GradObj</span><span class="scilabstring">&#0034;</span><span class="scilabdefault">,</span><span class="scilabstring">&#0034;</span><span class="scilabstring">on</span><span class="scilabstring">&#0034;</span><span class="scilabopenclose">)</span><span class="scilabdefault">;</span></pre></td><td valign="top"><a href="scilab://scilab.execexample/"><img src="ScilabExecute.png" border="0"/></a></td><td valign="top"><a href="scilab://scilab.editexample/"><img src="ScilabEdit.png" border="0"/></a></td><td></td></tr></table></div>
This will let fmincon know that the exact gradient of the objective
function is known, so that it can change the calling sequence to the
objective function.</p>
   <p class="para">The constraint function must have header :
<div class="programlisting"><table border="0" width="100%"><tr><td width="98%"><pre class="scilabcode"><span class="scilabopenclose">[</span><span class="scilabid">c</span><span class="scilabdefault">,</span> <span class="scilabid">ceq</span><span class="scilabopenclose">]</span> <span class="scilaboperator">=</span> <span class="scilabid">confun</span><span class="scilabopenclose">(</span><span class="scilabid">x</span><span class="scilabopenclose">)</span></pre></td><td valign="top"><a href="scilab://scilab.execexample/"><img src="ScilabExecute.png" border="0"/></a></td><td valign="top"><a href="scilab://scilab.editexample/"><img src="ScilabEdit.png" border="0"/></a></td><td></td></tr></table></div>
where x is a n x 1 matrix of doubles, c is a nni x 1 matrix of doubles and
ceq is a nne x 1 matrix of doubles (nni : number of nonlinear inequality
constraints, nne : number of nonlinear equality constraints).
On input, the variable x contains the current point and, on output,
the variable c must contain the nonlinear inequality constraints and ceq must contain the
nonlinear equality constraints.</p>
   <p class="para">By default, fmincon uses finite differences with order 2 formulas and
optimum step size in order to compute a numerical gradient of the
constraint function.
In order to use exact gradients, we must update the header of the
constraint function to :
<div class="programlisting"><table border="0" width="100%"><tr><td width="98%"><pre class="scilabcode"><span class="scilabopenclose">[</span><span class="scilabid">c</span><span class="scilabdefault">,</span><span class="scilabid">ceq</span><span class="scilabdefault">,</span><span class="scilabid">DC</span><span class="scilabdefault">,</span><span class="scilabid">DCeq</span><span class="scilabopenclose">]</span> <span class="scilaboperator">=</span> <span class="scilabid">confungrad</span><span class="scilabopenclose">(</span><span class="scilabid">x</span><span class="scilabopenclose">)</span></pre></td><td valign="top"><a href="scilab://scilab.execexample/"><img src="ScilabExecute.png" border="0"/></a></td><td valign="top"><a href="scilab://scilab.editexample/"><img src="ScilabEdit.png" border="0"/></a></td><td></td></tr></table></div>
where x is a n x 1 matrix of doubles, c is a nni x 1 matrix of doubles,
ceq is a nne x 1 matrix of doubles, DC is a n x nni matrix of doubles and
DCeq is a n x nne matrix of doubles.
On input, the variable x contains the current point and, on output,
the variable c must contain the nonlinear inequality constraint function value,
the variable ceq must contain the nonlinear equality constraint function value,
the variable DC must contain the Jacobian matrix of the nonlinear inequality constraints
and the variable DCeq must contain the Jacobian matrix of the nonlinear equality constraints.
The i-th nonlinear inequality constraint is associated to the i-th column of
the matrix DC, i.e, it is stored in DC(:,i) (same for DCeq).
Furthermore, we must enable the &#0034;GradObj&#0034; option with the statement :
<div class="programlisting"><table border="0" width="100%"><tr><td width="98%"><pre class="scilabcode"><span class="scilabid">options</span> <span class="scilaboperator">=</span> <a class="scilabmacro" href="optimset.html">optimset</a><span class="scilabopenclose">(</span><span class="scilabstring">&#0034;</span><span class="scilabstring">GradConstr</span><span class="scilabstring">&#0034;</span><span class="scilabdefault">,</span><span class="scilabstring">&#0034;</span><span class="scilabstring">on</span><span class="scilabstring">&#0034;</span><span class="scilabopenclose">)</span><span class="scilabdefault">;</span></pre></td><td valign="top"><a href="scilab://scilab.execexample/"><img src="ScilabExecute.png" border="0"/></a></td><td valign="top"><a href="scilab://scilab.editexample/"><img src="ScilabEdit.png" border="0"/></a></td><td></td></tr></table></div></p>
   <p class="para">By default, fmincon uses a L-BFGS formula to compute an
approximation of the Hessian of the Lagrangian.
Notice that this is different from Matlab&#0039;s fmincon, which
default is to use a BFGS.</p>
   <p class="para">The exitflag variable allows to know the status of the optimization.
<ul class="itemizedlist"><li>exitflag=0 : Number of iterations exceeded options.MaxIter or number of function evaluations exceeded options.FunEvals.</li>
<li>exitflag=1 : First-order optimality measure was less than options.TolFun, and maximum constraint violation was less than options.TolCon.</li>
<li>exitflag=-1 : The output function terminated the algorithm.</li>
<li>exitflag=-2 : No feasible point was found.</li>
<li>exitflag=%nan : Other type of termination.</li></ul></p>
   <p class="para">The output data structure contains detailed informations about the
optimization process.
It has type &#0034;struct&#0034; and contains the following fields.
<ul class="itemizedlist"><li>output.iterations: the number of iterations performed during the search</li>
<li>output.funcCount: the number of function evaluations during the search</li>
<li>output.stepsize: an empty matrix</li>
<li>output.algorithm : the string containing the name of the algorithm. In the current version, algorithm=&#0034;ipopt&#0034;.</li>
<li>output.firstorderopt: the max-norm of the first-order KKT conditions.</li>
<li>output.constrviolation: the max-norm of the constraint violation.</li>
<li>output.cgiterations: the number of preconditionned conjugate gradient steps. In the current version, cgiterations=0.</li>
<li>output.message: a string containing a message describing the status of the optimization.</li></ul></p>
   <p class="para">The lambda data structure contains the Lagrange multipliers at the
end of optimization.
It has type &#0034;struct&#0034; and contains the following
fields.
<ul class="itemizedlist"><li>lambda.lower: the Lagrange multipliers for the lower bound constraints. In the current version, an empty matrix.</li>
<li>lambda.upper: the Lagrange multipliers for the upper bound constraints. In the current version, an empty matrix.</li>
<li>lambda.eqlin: the Lagrange multipliers for the linear equality constraints.</li>
<li>lambda.eqnonlin: the Lagrange multipliers for the nonlinear equality constraints.</li>
<li>lambda.ineqlin: the Lagrange multipliers for the linear inequality constraints.</li>
<li>lambda.ineqnonlin: the Lagrange multipliers for the nonlinear inequality constraints.</li></ul></p>
   <p class="para">TODO : exitflag=2 : Change in x was less than options.TolX and maximum constraint violation was less than options.TolCon.
TODO : exitflag=-3 : Current point x went below options.ObjectiveLimit and maximum constraint violation was less than options.TolCon.
TODO : fill lambda.lower and lambda.upper consistently. See ticket #111 : http://forge.scilab.org/index.php/p/sci-ipopt/issues/111/
TODO : test with A, b
TODO : test with Aeq, beq
TODO : test with ceq
TODO : avoid using global for ipopt_data
TODO : implement Display option
TODO : implement FinDiffType option
TODO : implement MaxFunEvals option
TODO : implement DerivativeCheck option
TODO : implement MaxIter option
TODO : implement OutputFcn option
TODO : implement PlotFcns option
TODO : implement TolFun option
TODO : implement TolCon option
TODO : implement TolX option
TODO : implement Hessian option
TODO : check that the hessian output argument is Hessian of f only
TODO : test all exitflag values</p>
   <p class="para"></p></div>

<div class="refsection"><h3 class="title">Examples</h3>
   <div class="programlisting"><table border="0" width="100%"><tr><td width="98%"><pre class="scilabcode"><span class="scilabcomment">// A basic case :</span>
<span class="scilabcomment">// we provide only the objective function and the nonlinear constraint</span>
<span class="scilabcomment">// function : we let fmincon compute the gradients by numerical</span>
<span class="scilabcomment">// derivatives.</span>
<span class="scilabfkeyword">function</span> <span class="scilabinputoutputargs">f</span><span class="scilaboperator">=</span><span class="scilabfunctionid">objfun</span><span class="scilabopenclose">(</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">)</span>
<span class="scilabinputoutputargs">f</span> <span class="scilaboperator">=</span> <a class="scilabcommand" href="scilab://exp">exp</a><span class="scilabopenclose">(</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilabopenclose">)</span><span class="scilaboperator">*</span><span class="scilabopenclose">(</span><span class="scilabnumber">4</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilaboperator">^</span><span class="scilabnumber">2</span> <span class="scilaboperator">+</span> <span class="scilabnumber">2</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span><span class="scilaboperator">^</span><span class="scilabnumber">2</span> <span class="scilaboperator">+</span> <span class="scilabnumber">4</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span> <span class="scilaboperator">+</span> <span class="scilabnumber">2</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span> <span class="scilaboperator">+</span> <span class="scilabnumber">1</span><span class="scilabopenclose">)</span>
<span class="scilabfkeyword">endfunction</span>
<span class="scilabfkeyword">function</span> <span class="scilabopenclose">[</span><span class="scilabinputoutputargs">c</span><span class="scilabdefault">, </span><span class="scilabinputoutputargs">ceq</span><span class="scilabopenclose">]</span><span class="scilaboperator">=</span><span class="scilabfunctionid">confun</span><span class="scilabopenclose">(</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">)</span>
<span class="scilabcomment">// Nonlinear inequality constraints</span>
<span class="scilabinputoutputargs">c</span> <span class="scilaboperator">=</span> <span class="scilabopenclose">[</span>
<span class="scilabnumber">1.5</span> <span class="scilaboperator">+</span> <span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span> <span class="scilaboperator">-</span> <span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span> <span class="scilaboperator">-</span> <span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span>
<span class="scilaboperator">-</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span> <span class="scilaboperator">-</span> <span class="scilabnumber">10</span>
<span class="scilabopenclose">]</span>
<span class="scilabcomment">// Nonlinear equality constraints</span>
<span class="scilabinputoutputargs">ceq</span> <span class="scilaboperator">=</span> <span class="scilabopenclose">[</span><span class="scilabopenclose">]</span>
<span class="scilabfkeyword">endfunction</span>
<span class="scilabcomment">// The initial guess</span>
<span class="scilabid">x0</span> <span class="scilaboperator">=</span> <span class="scilabopenclose">[</span><span class="scilaboperator">-</span><span class="scilabnumber">1</span><span class="scilabdefault">,</span><span class="scilabnumber">1</span><span class="scilabopenclose">]</span><span class="scilabdefault">;</span>
<span class="scilabcomment">// The expected solution : only 4 digits are guaranteed</span>
<span class="scilabid">xopt</span> <span class="scilaboperator">=</span> <span class="scilabopenclose">[</span><span class="scilaboperator">-</span><span class="scilabnumber">9.547345885974547</span>   <span class="scilabnumber">1.047408305349257</span><span class="scilabopenclose">]</span>
<span class="scilabid">fopt</span> <span class="scilaboperator">=</span> <span class="scilabnumber">0.023551460139148</span>
<span class="scilabcomment">// Run fmincon</span>
<span class="scilabopenclose">[</span><span class="scilabid">x</span><span class="scilabdefault">,</span><span class="scilabid">fval</span><span class="scilabdefault">,</span><span class="scilabid">exitflag</span><span class="scilabdefault">,</span><span class="scilabid">output</span><span class="scilabdefault">,</span><span class="scilabid">lambda</span><span class="scilabdefault">,</span><span class="scilabid">grad</span><span class="scilabdefault">,</span><span class="scilabid">hessian</span><span class="scilabopenclose">]</span> <span class="scilaboperator">=</span> <span class="scilabspecial">..</span>
<span class="scilabid">fmincon</span> <span class="scilabopenclose">(</span> <span class="scilabfunctionid">objfun</span><span class="scilabdefault">,</span><span class="scilabid">x0</span><span class="scilabdefault">,</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span><span class="scilabdefault">,</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span><span class="scilabdefault">,</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span><span class="scilabdefault">,</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span><span class="scilabdefault">,</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span><span class="scilabdefault">,</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span><span class="scilabdefault">,</span> <span class="scilabfunctionid">confun</span> <span class="scilabstring">)</span></pre></td><td valign="top"><a href="scilab://scilab.execexample/"><img src="ScilabExecute.png" border="0"/></a></td><td valign="top"><a href="scilab://scilab.editexample/"><img src="ScilabEdit.png" border="0"/></a></td><td></td></tr></table></div></div>

<div class="refsection"><h3 class="title">Examples</h3>
   <div class="programlisting"><table border="0" width="100%"><tr><td width="98%"><pre class="scilabcode"><span class="scilabcomment">// A case where we provide the gradient of the objective</span>
<span class="scilabcomment">// function and the Jacobian matrix of the constraints.</span>
<span class="scilabcomment">// The objective function and its gradient</span>
<span class="scilabfkeyword">function</span> <span class="scilabopenclose">[</span><span class="scilabinputoutputargs">f</span><span class="scilabdefault">, </span><span class="scilabinputoutputargs">G</span><span class="scilabopenclose">]</span><span class="scilaboperator">=</span><span class="scilabfunctionid">objfungrad</span><span class="scilabopenclose">(</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">)</span>
<span class="scilabopenclose">[</span><span class="scilabid">lhs</span><span class="scilabdefault">,</span><span class="scilabid">rhs</span><span class="scilabopenclose">]</span><span class="scilaboperator">=</span><a class="scilabcommand" href="scilab://argn">argn</a><span class="scilabopenclose">(</span><span class="scilabopenclose">)</span>
<span class="scilabinputoutputargs">f</span> <span class="scilaboperator">=</span> <a class="scilabcommand" href="scilab://exp">exp</a><span class="scilabopenclose">(</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilabopenclose">)</span><span class="scilaboperator">*</span><span class="scilabopenclose">(</span><span class="scilabnumber">4</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilaboperator">^</span><span class="scilabnumber">2</span><span class="scilaboperator">+</span><span class="scilabnumber">2</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span><span class="scilaboperator">^</span><span class="scilabnumber">2</span><span class="scilaboperator">+</span><span class="scilabnumber">4</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span><span class="scilaboperator">+</span><span class="scilabnumber">2</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span><span class="scilaboperator">+</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span>
<span class="scilabskeyword">if</span> <span class="scilabopenclose">(</span> <span class="scilabid">lhs</span>  <span class="scilaboperator">&#0062;</span> <span class="scilabnumber">1</span> <span class="scilabopenclose">)</span> <span class="scilabskeyword">then</span>
<span class="scilabinputoutputargs">G</span> <span class="scilaboperator">=</span> <span class="scilabopenclose">[</span>
<span class="scilabinputoutputargs">f</span> <span class="scilaboperator">+</span> <a class="scilabcommand" href="scilab://exp">exp</a><span class="scilabopenclose">(</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilabopenclose">)</span> <span class="scilaboperator">*</span> <span class="scilabopenclose">(</span><span class="scilabnumber">8</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span> <span class="scilaboperator">+</span> <span class="scilabnumber">4</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span><span class="scilabopenclose">)</span>
<a class="scilabcommand" href="scilab://exp">exp</a><span class="scilabopenclose">(</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilabopenclose">)</span><span class="scilaboperator">*</span><span class="scilabopenclose">(</span><span class="scilabnumber">4</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilaboperator">+</span><span class="scilabnumber">4</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span><span class="scilaboperator">+</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span>
<span class="scilabopenclose">]</span>
<span class="scilabskeyword">end</span>
<span class="scilabfkeyword">endfunction</span>
<span class="scilabcomment">// The nonlinear constraints and the Jacobian</span>
<span class="scilabcomment">// matrix of the constraints</span>
<span class="scilabfkeyword">function</span> <span class="scilabopenclose">[</span><span class="scilabinputoutputargs">c</span><span class="scilabdefault">, </span><span class="scilabinputoutputargs">ceq</span><span class="scilabdefault">, </span><span class="scilabinputoutputargs">DC</span><span class="scilabdefault">, </span><span class="scilabinputoutputargs">DCeq</span><span class="scilabopenclose">]</span><span class="scilaboperator">=</span><span class="scilabfunctionid">confungrad</span><span class="scilabopenclose">(</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">)</span>
<span class="scilabcomment">// Inequality constraints</span>
<span class="scilabinputoutputargs">c</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span> <span class="scilaboperator">=</span> <span class="scilabnumber">1.5</span> <span class="scilaboperator">+</span> <span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span> <span class="scilaboperator">*</span> <span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span> <span class="scilaboperator">-</span> <span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span> <span class="scilaboperator">-</span> <span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span>
<span class="scilabinputoutputargs">c</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span> <span class="scilaboperator">=</span> <span class="scilaboperator">-</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span> <span class="scilaboperator">*</span> <span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span><span class="scilaboperator">-</span><span class="scilabnumber">10</span>
<span class="scilabcomment">// No nonlinear equality constraints</span>
<span class="scilabinputoutputargs">ceq</span><span class="scilaboperator">=</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span>
<span class="scilabopenclose">[</span><span class="scilabid">lhs</span><span class="scilabdefault">,</span><span class="scilabid">rhs</span><span class="scilabopenclose">]</span><span class="scilaboperator">=</span><a class="scilabcommand" href="scilab://argn">argn</a><span class="scilabopenclose">(</span><span class="scilabopenclose">)</span>
<span class="scilabskeyword">if</span> <span class="scilabopenclose">(</span> <span class="scilabid">lhs</span> <span class="scilaboperator">&#0062;</span> <span class="scilabnumber">2</span> <span class="scilabopenclose">)</span> <span class="scilabskeyword">then</span>
<span class="scilabcomment">// DC(:,i) = gradient of the i-th constraint</span>
<span class="scilabcomment">// DC = [</span>
<span class="scilabcomment">//   Dc1/Dx1  Dc2/Dx1</span>
<span class="scilabcomment">//   Dc1/Dx2  Dc2/Dx2</span>
<span class="scilabcomment">//   ]</span>
<span class="scilabinputoutputargs">DC</span><span class="scilaboperator">=</span> <span class="scilabopenclose">[</span>
<span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span><span class="scilaboperator">-</span><span class="scilabnumber">1</span><span class="scilabdefault">,</span> <span class="scilaboperator">-</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span>
<span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilaboperator">-</span><span class="scilabnumber">1</span><span class="scilabdefault">,</span> <span class="scilaboperator">-</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span>
<span class="scilabopenclose">]</span>
<span class="scilabinputoutputargs">DCeq</span> <span class="scilaboperator">=</span> <span class="scilabopenclose">[</span><span class="scilabopenclose">]</span>
<span class="scilabskeyword">end</span>
<span class="scilabfkeyword">endfunction</span>
<span class="scilabcomment">// Test with both gradient of objective and gradient of constraints</span>
<span class="scilabid">options</span> <span class="scilaboperator">=</span> <a class="scilabmacro" href="optimset.html">optimset</a><span class="scilabopenclose">(</span><span class="scilabstring">&#0034;</span><span class="scilabstring">GradObj</span><span class="scilabstring">&#0034;</span><span class="scilabdefault">,</span><span class="scilabstring">&#0034;</span><span class="scilabstring">on</span><span class="scilabstring">&#0034;</span><span class="scilabdefault">,</span><span class="scilabstring">&#0034;</span><span class="scilabstring">GradConstr</span><span class="scilabstring">&#0034;</span><span class="scilabdefault">,</span><span class="scilabstring">&#0034;</span><span class="scilabstring">on</span><span class="scilabstring">&#0034;</span><span class="scilabopenclose">)</span><span class="scilabdefault">;</span>
<span class="scilabcomment">// The initial guess</span>
<span class="scilabid">x0</span> <span class="scilaboperator">=</span> <span class="scilabopenclose">[</span><span class="scilaboperator">-</span><span class="scilabnumber">1</span><span class="scilabdefault">,</span><span class="scilabnumber">1</span><span class="scilabopenclose">]</span><span class="scilabdefault">;</span>
<span class="scilabcomment">// The expected solution : only 4 digits are guaranteed</span>
<span class="scilabid">xopt</span> <span class="scilaboperator">=</span> <span class="scilabopenclose">[</span><span class="scilaboperator">-</span><span class="scilabnumber">9.547345885974547</span>   <span class="scilabnumber">1.047408305349257</span><span class="scilabopenclose">]</span>
<span class="scilabid">fopt</span> <span class="scilaboperator">=</span> <span class="scilabnumber">0.023551460139148</span>
<span class="scilabcomment">// Run fmincon</span>
<span class="scilabopenclose">[</span><span class="scilabid">x</span><span class="scilabdefault">,</span><span class="scilabid">fval</span><span class="scilabdefault">,</span><span class="scilabid">exitflag</span><span class="scilabdefault">,</span><span class="scilabid">output</span><span class="scilabopenclose">]</span> <span class="scilaboperator">=</span> <span class="scilabspecial">..</span>
<span class="scilabid">fmincon</span><span class="scilabopenclose">(</span><span class="scilabfunctionid">objfungrad</span><span class="scilabdefault">,</span><span class="scilabid">x0</span><span class="scilabdefault">,</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span><span class="scilabdefault">,</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span><span class="scilabdefault">,</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span><span class="scilabdefault">,</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span><span class="scilabdefault">,</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span><span class="scilabdefault">,</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span><span class="scilabdefault">,</span> <span class="scilabfunctionid">confungrad</span><span class="scilabdefault">,</span><span class="scilabid">options</span><span class="scilabopenclose">)</span></pre></td><td valign="top"><a href="scilab://scilab.execexample/"><img src="ScilabExecute.png" border="0"/></a></td><td valign="top"><a href="scilab://scilab.editexample/"><img src="ScilabEdit.png" border="0"/></a></td><td></td></tr></table></div></div>

<div class="refsection"><h3 class="title">Examples</h3>
   <div class="programlisting"><table border="0" width="100%"><tr><td width="98%"><pre class="scilabcode"><span class="scilabcomment">// A case where we set the bounds of the optimization.</span>
<span class="scilabcomment">// By default, the bounds are set to infinity.</span>
<span class="scilabfkeyword">function</span> <span class="scilabinputoutputargs">f</span><span class="scilaboperator">=</span><span class="scilabfunctionid">objfun</span><span class="scilabopenclose">(</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">)</span>
<span class="scilabinputoutputargs">f</span> <span class="scilaboperator">=</span> <a class="scilabcommand" href="scilab://exp">exp</a><span class="scilabopenclose">(</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilabopenclose">)</span><span class="scilaboperator">*</span><span class="scilabopenclose">(</span><span class="scilabnumber">4</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilaboperator">^</span><span class="scilabnumber">2</span> <span class="scilaboperator">+</span> <span class="scilabnumber">2</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span><span class="scilaboperator">^</span><span class="scilabnumber">2</span> <span class="scilaboperator">+</span> <span class="scilabnumber">4</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span> <span class="scilaboperator">+</span> <span class="scilabnumber">2</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span> <span class="scilaboperator">+</span> <span class="scilabnumber">1</span><span class="scilabopenclose">)</span>
<span class="scilabfkeyword">endfunction</span>
<span class="scilabfkeyword">function</span> <span class="scilabopenclose">[</span><span class="scilabinputoutputargs">c</span><span class="scilabdefault">, </span><span class="scilabinputoutputargs">ceq</span><span class="scilabopenclose">]</span><span class="scilaboperator">=</span><span class="scilabfunctionid">confun</span><span class="scilabopenclose">(</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">)</span>
<span class="scilabcomment">// Nonlinear inequality constraints</span>
<span class="scilabinputoutputargs">c</span> <span class="scilaboperator">=</span> <span class="scilabopenclose">[</span>
<span class="scilabnumber">1.5</span> <span class="scilaboperator">+</span> <span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span> <span class="scilaboperator">-</span> <span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span> <span class="scilaboperator">-</span> <span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span>
<span class="scilaboperator">-</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">1</span><span class="scilabopenclose">)</span><span class="scilaboperator">*</span><span class="scilabinputoutputargs">x</span><span class="scilabopenclose">(</span><span class="scilabnumber">2</span><span class="scilabopenclose">)</span> <span class="scilaboperator">-</span> <span class="scilabnumber">10</span>
<span class="scilabopenclose">]</span>
<span class="scilabcomment">// Nonlinear equality constraints</span>
<span class="scilabinputoutputargs">ceq</span> <span class="scilaboperator">=</span> <span class="scilabopenclose">[</span><span class="scilabopenclose">]</span>
<span class="scilabfkeyword">endfunction</span>
<span class="scilabcomment">// The initial guess</span>
<span class="scilabid">x0</span> <span class="scilaboperator">=</span> <span class="scilabopenclose">[</span><span class="scilaboperator">-</span><span class="scilabnumber">1</span><span class="scilabdefault">,</span><span class="scilabnumber">1</span><span class="scilabopenclose">]</span><span class="scilabdefault">;</span>
<span class="scilabcomment">// The expected solution</span>
<span class="scilabid">xopt</span> <span class="scilaboperator">=</span> <span class="scilabopenclose">[</span><span class="scilabnumber">0</span>   <span class="scilabnumber">1.5</span><span class="scilabopenclose">]</span>
<span class="scilabid">fopt</span> <span class="scilaboperator">=</span> <span class="scilabnumber">8.5</span>
<span class="scilabcomment">// Make sure that x(1)</span><span class="scilabcomment">&#0062;</span><span class="scilabcomment">=0, and x(2)</span><span class="scilabcomment">&#0062;</span><span class="scilabcomment">=0</span>
<span class="scilabid">lb</span> <span class="scilaboperator">=</span> <span class="scilabopenclose">[</span><span class="scilabnumber">0</span><span class="scilabdefault">,</span><span class="scilabnumber">0</span><span class="scilabopenclose">]</span><span class="scilabdefault">;</span>
<span class="scilabid">ub</span> <span class="scilaboperator">=</span> <span class="scilabopenclose">[</span> <span class="scilabopenclose">]</span><span class="scilabdefault">;</span>
<span class="scilabcomment">// Run fmincon</span>
<span class="scilabopenclose">[</span><span class="scilabid">x</span><span class="scilabdefault">,</span><span class="scilabid">fval</span><span class="scilabopenclose">]</span> <span class="scilaboperator">=</span> <span class="scilabid">fmincon</span> <span class="scilabopenclose">(</span> <span class="scilabfunctionid">objfun</span> <span class="scilabdefault">,</span> <span class="scilabid">x0</span><span class="scilabdefault">,</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span><span class="scilabdefault">,</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span><span class="scilabdefault">,</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span><span class="scilabdefault">,</span><span class="scilabopenclose">[</span><span class="scilabopenclose">]</span><span class="scilabdefault">,</span><span class="scilabid">lb</span><span class="scilabdefault">,</span><span class="scilabid">ub</span><span class="scilabdefault">,</span><span class="scilabfunctionid">confun</span><span class="scilabopenclose">)</span></pre></td><td valign="top"><a href="scilab://scilab.execexample/"><img src="ScilabExecute.png" border="0"/></a></td><td valign="top"><a href="scilab://scilab.editexample/"><img src="ScilabEdit.png" border="0"/></a></td><td></td></tr></table></div></div>

<div class="refsection"><h3 class="title">Authors</h3>
   <ul class="itemizedlist"><li class="member">Michael Baudin, DIGITEO, 2010</li></ul></div>
    <br />

    <div class="manualnavbar">
    <table width="100%">
    <tr><td colspan="3" class="next"><a href="http://bugzilla.scilab.org/enter_bug.cgi?product=Scilab%20software&component=Documentation%20pages" class="ulink">Report an issue</a></td></tr>
<tr>
      <td width="30%">
    	<span class="previous"><a href="section_ed3c614d9a2555a6802170ca29940f55.html">&lt;&lt; Fmincon Toolbox</a></span>

      </td>
      <td width="40%" class="center">
      	<span class="top"><a href="section_ed3c614d9a2555a6802170ca29940f55.html">Fmincon Toolbox</a></span>

      </td>
      <td width="30%" class="next">
      	<span class="next"><a href="optimget.html">optimget &gt;&gt;</a></span>

      </td>
    </tr></table>
      <hr />
    </div>
  </body>
</html>
